<cfoutput>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by colddoc on #Now()# -->
<TITLE>
Callable
</TITLE>

<META NAME="keywords" CONTENT="#arguments.package#.concurrent.Callable interface">

<cfset instance.class.root = RepeatString('../', ListLen(arguments.package, ".")) />

<LINK REL ="stylesheet" TYPE="text/css" HREF="#instance.class.root#stylesheet.css" TITLE="Style">
<link href='https://fonts.googleapis.com/css?family=Ubuntu:400,300,300italic,400italic,700,700italic|Ubuntu+Mono' rel='stylesheet' type='text/css' />
<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="#arguments.name#";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<cfmodule template="inc/nav.html"
			page="Class"
			projectTitle= "#arguments.projectTitle#"
			package = "#arguments.package#"
			file="#replace(arguments.package, '.', '/', 'all')#/#arguments.name#"
			>

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
#arguments.package#</FONT>
<BR>
<cfif arguments.metadata.type eq "interface">
Interface
<cfelse>
Class
</cfif>
 #arguments.name#</H2>

<cfset local.i = 0 />

<cfset local.ls = createObject("java", "java.lang.System").getProperty("line.separator") />
<cfset local.buffer = createObject("java", "java.lang.StringBuffer").init() />
<cfset local.thisClass = arguments.package & "." & arguments.name/>

<cfloop array="#getInheritence(arguments.metadata)#" index="className">
	<cfif local.i++ gt 0>
		<cfset local.buffer.append('#RepeatString("    ", local.i)#<IMG SRC="#instance.class.root#resources/inherit.gif" ALT="extended by ">') />
		<cfif className neq local.thisClass>
			<cfset local.buffer.append(writeClassLink(getPackage(className), getObjectName(className), arguments.qMetaData, "long")) />
		<cfelse>
			<cfset local.buffer.append(className) />
		</cfif>
	<cfelse>
		<cfset local.buffer.append(className) />
	</cfif>
	<cfset local.buffer.append(local.ls) />
</cfloop>

<PRE>#local.buffer.toString()#</PRE>

<cfif arguments.metadata.type eq "component">
	<cfset interfaces = getImplements(arguments.metadata)>
	<cfif NOT arrayIsEmpty(interfaces)>
		<DL>
		<DT><B>All Implemented Interfaces:</B>
		<DD>
		<cfset local.len = arrayLen(interfaces)>
		<cfloop from="1" to="#local.len#" index="local.counter">
			<cfset interface = interfaces[local.counter]>
			<cfif local.counter neq 1>,</cfif>
			#writeClassLink(getPackage(interface), getObjectName(interface), arguments.qMetaData, "short")#
		</cfloop>
		</DD>
		</DL>
	</cfif>
<cfelse>
	<cfif arguments.qImplementing.recordCount>
	<DL>
	<DT><B>All Known Implementing Classes:</B>
	<DD>
		<cfloop query="arguments.qImplementing">
			<cfif arguments.qImplementing.currentRow neq 1>,</cfif>
			#writeClassLink(arguments.qImplementing.package, arguments.qImplementing.name, arguments.qMetaData, "short")#
		</cfloop>
	</DD>
	</DL>
	</cfif>
</cfif>

<cfif arguments.qSubclass.recordCount>
<DL>
<DT><B><cfif arguments.metadata.type eq "component">Direct Known Subclasses<cfelse>All Known Subinterfaces</cfif>:</B>
<DD>
	<cfloop query="arguments.qSubclass">
		<cfif arguments.qSubclass.currentRow neq 1>,</cfif>
		<A HREF="#instance.class.root#/#replace(arguments.qSubclass.package, '.', '/', 'all')#/#arguments.qSubclass.name#.html" title="class in #arguments.package#">#arguments.qSubclass.name#</A>
	</cfloop>
</DD>
</DL>
</cfif>

<HR>
<DL>
<DT>

<cfscript>
	local.buffer.setLength(0);
	local.buffer.append("public ");
	if(isAbstractClass(name, arguments.package))
	{
		local.buffer.append("abstract ");
	}

	if(arguments.metadata.type eq "interface")
	{
		local.buffer.append("interface");
	}
	else
	{
		local.buffer.append("class");
	}

	local.buffer.append(" <B>#arguments.name#</B>");
	local.buffer.append(local.ls);
	if(StructKeyExists(arguments.metadata, "extends"))
	{
		local.extendsmeta = arguments.metadata.extends;
		if(arguments.metadata.type eq "interface")
		{
			local.extendsmeta = arguments.metadata.extends[structKeyList(local.extendsmeta)];
		}
		local.buffer.append("<DT>extends #writeClassLink(getPackage(local.extendsmeta.name), getObjectName(local.extendsmeta.name), arguments.qMetaData, 'short')#</DT>");
	}
</cfscript>

<PRE>#local.buffer.toString()#</PRE>
</DT>
</DL>

<cfif StructKeyExists(arguments.metadata, "hint")>
<P>
	#arguments.metadata.hint#
<P>
</cfif>

<cfscript>
	instance.class.cache = StructNew();
	local.localFunctions = StructNew();
	
	local.qFunctions = buildFunctionMetaData(arguments.metadata);
	local.qProperties = buildPropertyMetadata(arguments.metadata);

	local.qInit = getMetaSubQuery(local.qFunctions, "UPPER(name)='INIT'");
</cfscript>

<cfif local.qProperties.recordCount>
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="##CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="5">
	<FONT SIZE="+2">
	<B>Property Summary</B>
	</FONT>
</TH>
</TR>

<TR BGCOLOR="##CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left">
	<FONT SIZE="+2">
	<B>Type</B>
	</FONT>
</TH>
<TH ALIGN="left">
	<FONT SIZE="+2">
	<B>Property & Description</B>
	</FONT>
</TH>
<TH ALIGN="left">
	<FONT SIZE="+2">
	<B>Default</B>
	</FONT>
</TH>
<TH ALIGN="left">
	<FONT SIZE="+2">
	<B>Serializable</B>
	</FONT>
</TH>
<TH ALIGN="left">
	<FONT SIZE="+2">
	<B>Required</B>
	</FONT>
</TH>
</TR>

<cfloop query="local.qProperties">
<cfset local.prop = local.qProperties.metadata />
<cfset local.localProperties[ local.prop.name ] = 1 />
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%">
	<FONT SIZE="-1">
		<CODE>
			&nbsp;#writeTypeLink(local.prop.type, arguments.package, arguments.qMetadata, local.prop)#
		</CODE>
	</FONT>
</TD>
<TD>
	#writeMethodLink(arguments.name, arguments.package, local.prop, arguments.qMetaData)# 
	<BR>
	<cfif StructKeyExists(local.prop, "hint") AND Len(local.prop.hint)>
	<!--- only grab the first sentence of the hint --->
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#listGetAt(local.prop.hint, 1, ".")#
	</cfif>
	
	<br><br>
	<strong>Attributes:</strong>
	<ul>
	<cfloop collection="#local.prop#" item="local.propmeta">
		<cfif not listFindNoCase( "hint,name,default,type,serializable,required", local.propmeta ) >
		<li>#lcase( local.propmeta )# = #local.prop[ local.propmeta ]#</li>
		</cfif>
	</cfloop>
	</ul>

</TD>
<TD ALIGN="right" VALIGN="top" WIDTH="1%">
	<FONT SIZE="-1">
		<CODE>
			#local.prop.default#
		</CODE>
	</FONT>
</TD>
<TD ALIGN="right" VALIGN="top" WIDTH="1%">
	<FONT SIZE="-1">
		<CODE>
			#local.prop.serializable#
		</CODE>
	</FONT>
</TD>
<TD ALIGN="right" VALIGN="top" WIDTH="1%">
	<FONT SIZE="-1">
		<CODE>
			#local.prop.required#
		</CODE>
	</FONT>
</TD>
</TR>
</cfloop>
</TR>
</TABLE>
&nbsp;
</cfif>


<cfif local.qInit.recordCount>
	<cfset local.init = local.qInit.metadata />
	<cfset local.localFunctions[local.init.name] = 1 />
	<!-- ======== CONSTRUCTOR SUMMARY ======== -->

	<A NAME="constructor_summary"><!-- --></A>
	<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
	<TR BGCOLOR="##CCCCFF" CLASS="TableHeadingColor">
	<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
	<B>Constructor Summary</B></FONT></TH>
	</TR>
	<TR BGCOLOR="white" CLASS="TableRowColor">
	<cfif local.init.access neq "public">
		<td align="right" valign="top" width="1%"><font size="-1">
		<code>#local.init.access# </code></font></td>
	</cfif>
	<TD>
		#writeMethodLink(arguments.name, arguments.package, local.init, arguments.qMetaData)#
	<BR>
	<cfif StructKeyExists(local.init, "hint") and len( local.init.hint ) >
		<!--- only grab the first sentence of the hint --->
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#listGetAt(local.init.hint, 1, ".")#
	</cfif>
	</TD>
	</TR>
	</TABLE>
	&nbsp;
</cfif>

<cfset local.qFunctions = getMetaSubQuery(local.qFunctions, "UPPER(name)!='INIT'") />

<cfif local.qFunctions.recordCount>
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="##CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>

<cfloop query="local.qFunctions">
<cfset local.func = local.qFunctions.metadata />
<cfset local.localFunctions[local.func.name] = 1 />
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE><cfif local.func.access neq "public">#local.func.access#</cfif>&nbsp;#writeTypeLink(local.func.returnType, arguments.package, arguments.qMetadata, local.func)#</CODE></FONT></TD>
<TD>#writeMethodLink(arguments.name, arguments.package, local.func, arguments.qMetaData)#
<BR>
<cfif StructKeyExists(local.func, "hint") AND Len(local.func.hint)>
<!--- only grab the first sentence of the hint --->
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#listGetAt(local.func.hint, 1, ".")#
</cfif>
</TD>
</TR>
</cfloop>
</TR>
</TABLE>

</cfif>

<cfset local.localmeta = arguments.metadata />

<cfloop condition="#StructKeyExists(local.localmeta, 'extends')#">
	<cfscript>
		if(local.localmeta.type eq "interface")
		{
			local.localmeta = local.localmeta.extends[structKeyList(local.localmeta.extends)];
		}
		else
		{
			local.localmeta = local.localmeta.extends;
		}
    </cfscript>

	<cfset local.qFunctions = buildFunctionMetaData(local.localmeta)>

	&nbsp;
	<a name="methods_inherited_from_class_#local.localmeta.name#"><!-- --></a>
	<table summary="" border="1" cellpadding="3" cellspacing="0" width="100%">
	<tbody><tr class="TableSubHeadingColor" bgcolor="##eeeeff">
	<th align="left"><b>Methods inherited from class #writeClassLink(getPackage(local.localmeta.name), getObjectName(local.localmeta.name), arguments.qMetaData, 'long')#</b></th>
	</tr>
	<tr class="TableRowColor" bgcolor="white">
	<td>
		<cfset local.buffer.setLength(0) />
		<cfset i = 1 />
		<cfloop query="local.qFunctions">
			<cfset local.func = local.qFunctions.metadata />
			<cfif NOT StructKeyExists(local.localFunctions, local.func.name)>
			<cfif i++ neq 1>
				<cfset local.buffer.append(", ") />
			</cfif>
			<cfset local.buffer.append('<a href="#instance.class.root#/#replace(getPackage(local.localmeta.name), '.', '/', 'all')#/#getObjectName(local.localmeta.name)#.html###local.func.name#()">#local.func.name#</a>') />
			<cfset local.localFunctions[local.func.name] = 1 />
			</cfif>
		</cfloop>
		
		<cfif local.buffer.length()>
			<code>#local.buffer.toString()#</code>
		<cfelse>
			<code><em>None</em></code>
		</cfif>
	</td>
	</tr>
	</tbody></table>
</cfloop>

&nbsp;
<P>

<cfif StructKeyExists(local, "init")>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<a name="constructor_detail"><!-- --></a>
</p><table summary="" border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr class="TableHeadingColor" bgcolor="##ccccff">
<th colspan="1" align="left"><font size="+2">
<b>Constructor Detail</b></font></th>
</tr>
</tbody></table>

<a name="#local.init.name#()"><!-- --></a><h3>

#local.init.name#</h3>
<CODE>#local.init.access# #writeMethodLink(arguments.name, arguments.package, local.init, arguments.qMetaData, false)#</CODE>
<dl>
<dd>
<cfif StructKeyExists(local.init, "hint")>
#local.init.hint#
</cfif>
<p>
</p>
<cfif StructKeyExists(local.init, "parameters") AND ArrayLen(local.init.parameters)>
<dl>
<dt><b>Parameters:</b></dt>
<cfloop array="#local.init.parameters#" index="local.param">
<dd><code>#local.param.name#</code><cfif StructKeyExists(local.param, "hint")> - #local.param.hint#</cfif></dd>
</cfloop>
</dl>
</cfif>

</dd></dl>
<!--- <hr> --->
</cfif>

<cfif local.qProperties.recordCount>

<!-- ============ PROPERTY DETAIL ========== -->

<a name="property_detail"><!-- --></a>
<table summary="" border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr class="TableHeadingColor" bgcolor="##ccccff">
<th colspan="1" align="left"><font size="+2">
<b>Property Detail</b></font></th>
</tr>
</tbody></table>

<cfloop query="local.qProperties">
	<cfset local.prop = local.qProperties.metadata />
	<a name="#local.prop.name#()"><!-- --></a><h3>
	#local.prop.name#</h3>
	<code>#writeTypeLink(local.prop.type, arguments.package, arguments.qMetaData, local.prop)# #writeMethodLink(arguments.name, arguments.package, local.prop, arguments.qMetaData, false)#</code>

	<dl>
	<dd>
	<cfif StructKeyExists(local.prop, "hint") AND Len(local.prop.hint)>
	#local.prop.hint#
	</cfif>
	<p>
	</p></dd>

	<dl>
	<dt><b>Attributes:</b></dt>
	<cfloop collection="#local.prop#" item="local.param">
		<cfif not listFindNoCase( "name,type,hint", local.param )>
		<dd><code>#lcase( local.param )#</code> - #local.prop[ local.param ]#</dd>
		</cfif>
	</cfloop>
	</dl>

	</dd>
	</dl>
	<hr>
</cfloop>
</cfif>



<cfset local.qFunctions = buildFunctionMetaData(arguments.metadata) />
<cfset local.qFunctions = getMetaSubQuery(local.qFunctions, "UPPER(name)!='INIT'") />

<cfif local.qFunctions.recordCount>

<!-- ============ METHOD DETAIL ========== -->

<a name="method_detail"><!-- --></a>
<table summary="" border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr class="TableHeadingColor" bgcolor="##ccccff">
<th colspan="1" align="left"><font size="+2">
<b>Method Detail</b></font></th>
</tr>
</tbody></table>
<cfloop query="local.qFunctions">
	<cfset local.func = local.qFunctions.metadata />
	<a name="#local.func.name#()"><!-- --></a><h3>
	#local.func.name#</h3>
	<code>#local.func.access# #writeTypeLink(local.func.returnType, arguments.package, arguments.qMetaData, local.func)# #writeMethodLink(arguments.name, arguments.package, local.func, arguments.qMetaData, false)#</code>

	<dl>
	<dd>
	<cfif StructKeyExists(local.func, "hint") AND Len(local.func.hint)>
	#local.func.hint#
	</cfif>
	<p>
	</p></dd>

	<!---
		<dl>
			<dt><b>Specified by:</b></dt>
			<dd>
			<code>
				<a href="../../java/lang/Appendable.html#append%28java.lang.CharSequence%29">append</a>
			</code>
			 in interface
			<code>
			<a href="../../java/lang/Appendable.html" title="interface in java.lang">Appendable</a></code>
			</dd>
		</dl>
	 --->
	<cfif arguments.metadata.type eq "component">
		<cfset local.specified = findSpecifiedBy(arguments.metaData, local.func.name) />
		<cfif Len(local.specified)>
			<dl>
				<dt><b>Specified by:</b></dt>
				<dd>
				<code>
				<a href="#instance.class.root#/#replace(getPackage(local.specified), '.', '/', 'all')#/#getObjectName(local.specified)#.html###local.func.name#()">#local.func.name#</a></code>
				in interface
				<code>
					#writeClassLink(getPackage(local.specified), getObjectName(local.specified), arguments.qMetaData, 'short')#
				</code>
				</dd>
			</dl>
		</cfif>
	</cfif>

	<cfset local.overWrites = findOverwrite(arguments.metaData, local.func.name) />
	<cfif Len(local.overWrites)>
	<dl>
		<dt><b>Overrides:</b></dt>
		<dd>
		<code>
		<a href="#instance.class.root#/#replace(getPackage(local.overWrites), '.', '/', 'all')#/#getObjectName(local.overWrites)#.html###local.func.name#()">#local.func.name#</a></code>
		in class
		<code>
			#writeClassLink(getPackage(local.overWrites), getObjectName(local.overWrites), arguments.qMetaData, 'short')#
		</code>
		</dd>
	</dl>
	</cfif>

	<cfif StructKeyExists(local.func, "parameters") AND ArrayLen(local.func.parameters)>
	<dl>
	<dt><b>Parameters:</b></dt>
	<cfloop array="#local.func.parameters#" index="local.param">
	<dd><code>#local.param.name#</code><cfif StructKeyExists(local.param, "hint")> - #local.param.hint#</cfif></dd>
	</cfloop>
	</dl>
	</cfif>

	</dd>
	</dl>
	<hr>
</cfloop>
</cfif>

<cfmodule template="inc/nav.html"
			page="Class"
			projectTitle= "#arguments.projectTitle#"
			package = "#arguments.package#"
			file="#replace(arguments.package, '.', '/', 'all')#/#arguments.name#"
			>

<HR>

</BODY>
</HTML>
</cfoutput>
<cfsilent>
	<cffunction name="writeMethodLink" hint="draws a method link" access="private" returntype="string" output="false">
		<cfargument name="name" hint="the name of the class" type="string" required="Yes">
		<cfargument name="package" hint="out current package" type="string" required="Yes">
		<cfargument name="func" hint="the function to link to" required="Yes">
		<cfargument name="qMetaData" hint="the meta daya query" type="query" required="Yes">
		<cfargument name="drawMethodLink" hint="actually draw the link on the method" type="boolean" required="No" default="true">
		<cfset var param = 0 />
		<cfset var i = 1 />
		<cfset var builder = createObject("java", "java.lang.StringBuilder").init() />
		<cfsilent>

		<cfif StructKeyExists(arguments.func, "parameters")>
			<cfset builder.append("(") />
				<cfloop array="#arguments.func.parameters#" index="param">
					<cfscript>
						if(i++ neq 1)
						{
							builder.append(", ");
						}

						if(NOT StructKeyExists(param, "required"))
						{
							param.required = false;
						}

						if(NOT param.required)
						{
							builder.append("[");
						}
					</cfscript>

					<cfscript>
						safeParamMeta(param);
						builder.append(writeTypeLink(param.type, arguments.package, arguments.qMetadata, param));

						builder.append(" " & param.name);

						if(StructKeyExists(param, "default"))
						{
							builder.append("='" & param.default & "'");
						}

						if(NOT param.required)
						{
							builder.append("]");
						}
					</cfscript>
				</cfloop>
			<cfset builder.append(")") />
		</cfif>

		</cfsilent>
		<cfif arguments.drawMethodLink>
		<cfreturn '<CODE><B><A HREF="#arguments.name#.html###arguments.func.name#()">#arguments.func.name#</A></B>#builder.toString()#</CODE>'/>
		<cfelse>
		<cfreturn '<B>#arguments.func.name#</B>#builder.toString()#'/>
		</cfif>
	</cffunction>

	<cffunction name="writeTypeLink" hint="writes a link to a type, or a class" access="private" returntype="string" output="false">
		<cfargument name="type" hint="the type/class" type="string" required="Yes">
		<cfargument name="package" hint="the current package" type="string" required="Yes">
		<cfargument name="qMetaData" hint="the meta data query" type="query" required="Yes">
		<cfargument name="genericMeta" hint="optional meta that may contain generic type information" type="struct" required="No" default="#structNew()#">
		<cfscript>
			var result = createObject("java", "java.lang.StringBuilder").init();
			var local = {};

			if(isPrimitive(arguments.type))
			{
				result.append(arguments.type);
			}
			else
			{
				arguments.type = resolveClassName(arguments.type, arguments.package);
				result.append(writeClassLink(getPackage(arguments.type), getObjectName(arguments.type), arguments.qMetaData, 'short'));
			}

			if(NOT structIsEmpty(arguments.genericMeta))
			{
				local.array = getGenericTypes(arguments.genericMeta, arguments.package);
				if(NOT arrayIsEmpty(local.array))
				{
					result.append("&lt;");

					local.len = ArrayLen(local.array);
                    for(local.counter=1; local.counter lte local.len; local.counter++)
                    {
						if(local.counter neq 1)
						{
							result.append(",");
						}

                    	local.generic = local.array[local.counter];
						result.append(writeTypeLink(local.generic, arguments.package, arguments.qMetaData));
                    }

					result.append("&gt;");
				}
			}

			return result.toString();
        </cfscript>
	</cffunction>

	<cfscript>
		/*
		function getArgumentList(func)
		{
			var list = "";
			var len = 0;
			var counter = 1;
			var param = 0;

			if(StructKeyExists(arguments.func, "parameters"))
			{
				len = ArrayLen(arguments.func.parameters);
				for(; counter lte len; counter = counter + 1)
				{
					param = safeParamMeta(arguments.func.parameters[counter]);
					list = listAppend(list, param.type);
				}
			}

			return list;
		}
		*/

		function writeClassLink(package, name, qMetaData, format)
		{
			var qClass = getMetaSubQuery(arguments.qMetaData, "LOWER(package)=LOWER('#arguments.package#') AND LOWER(name)=LOWER('#arguments.name#')");
			var builder = 0;
			var safeMeta = 0;
			var title = 0;

			if(qClass.recordCount)
			{
				safeMeta = StructCopy(qClass.metadata);

				title = "class";
				if(safeMeta.type eq "interface")
				{
					title = "interface";
				}

				builder = createObject("java", "java.lang.StringBuilder").init();
				builder.append('<a href="#instance.class.root#/#replace(qClass.package, '.', '/', 'all')#/#qClass.name#.html" title="#title# in #qClass.package#">');
				if(arguments.format eq "short")
				{
					builder.append(qClass.name);
				}
				else
				{
					builder.append(qClass.package & "." & qClass.name);
				}
				builder.append("</a>");

				return builder.toString();
			}

			return package & "." & name;
		}

		function getInheritence(metadata)
		{
			var localmeta = arguments.metadata;
			var inheritence = [arguments.metadata.name];

			while(StructKeyExists(localmeta, "extends"))
			{
				//manage interfaces
				if(localmeta.type eq "interface")
				{
					localmeta = localmeta.extends[structKeyList(localmeta.extends)];
				}
				else
				{
					localmeta = localmeta.extends;
				}

				ArrayPrepend(inheritence, localmeta.name);
			}

			return inheritence;
		}

		function getImplements(metadata)
		{
			var localmeta = arguments.metadata;
			var interfaces = {};
			var key = 0;
			var imeta = 0;

			while(StructKeyExists(localmeta, "extends"))
			{
				if(StructKeyExists(localmeta, "implements"))
				{
					for(key in localmeta.implements)
					{
						imeta = localmeta.implements[local.key];
						interfaces[imeta.name] = 1;
					}
				}
				localmeta = localmeta.extends;
			}

			interfaces = structKeyArray(interfaces);

			arraySort(interfaces, "textnocase");

			return interfaces;
		}

		function findOverwrite(metadata, functionName)
		{
			var qFunctions = 0;

			while(StructKeyExists(arguments.metadata, "extends"))
			{
				if(arguments.metadata.type eq "interface")
				{
					arguments.metadata = arguments.metadata.extends[structKeyList(arguments.metadata.extends)];
				}
				else
				{
					arguments.metadata = arguments.metadata.extends;
				}

				qFunctions = buildFunctionMetaData(arguments.metadata);
				qFunctions = getMetaSubQuery(qFunctions, "name='#arguments.functionName#'");

				if(qFunctions.recordCount)
				{
					return arguments.metadata.name;

				}
			}

			return "";
		}

		function findSpecifiedBy(metadata, functionname)
		{
			var imeta = 0;
			var qFunctions = 0;
			var key = 0;

			if(structKeyExists(arguments.metadata, "implements"))
			{
				for(key in arguments.metadata.implements)
				{
					imeta = arguments.metadata.implements[local.key];

					qFunctions = buildFunctionMetaData(imeta);
					qFunctions = getMetaSubQuery(qFunctions, "name='#arguments.functionName#'");

					if(qFunctions.recordCount)
					{
						return imeta.name;
					}

					//now look up super-interfaces
					while(structKeyExists(imeta, "extends"))
					{
						imeta = imeta.extends[structKeyList(imeta.extends)];

						qFunctions = buildFunctionMetaData(imeta);
						qFunctions = getMetaSubQuery(qFunctions, "name='#arguments.functionName#'");

						if(qFunctions.recordCount)
						{
							return imeta.name;
						}
					}
				}

			}

			return "";
		}

		//stupid cleanup

		StructDelete(variables, "findOverwrite");
		StructDelete(variables, "writeTypeLink");
		StructDelete(variables, "writeMethodLink");
		StructDelete(variables, "getArgumentList");
		StructDelete(variables, "writeClassLink");
		StructDelete(variables, "getInheritence");
		StructDelete(variables, "writeObjectLink");
		StructDelete(variables, "getImplements");
		StructDelete(variables, "findSpecifiedBy");

		//store for resident data
		StructDelete(variables.instance, "class");
	</cfscript>
</cfsilent>